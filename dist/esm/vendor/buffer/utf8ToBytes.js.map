{"version":3,"file":"utf8ToBytes.js","sourceRoot":"","sources":["../../../../src/vendor/buffer/utf8ToBytes.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable */\n\n/**\n * Convert a string to a byte array\n *\n * This is a utf8ToBytes function from the buffer module (with added types)\n * https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L1956\n *\n * License: MIT (https://github.com/feross/buffer)\n */\nexport function utf8ToBytes(string: string, units?: number): number[] {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes: number[] = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n"]}